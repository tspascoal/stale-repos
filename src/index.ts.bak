import { Application } from 'probot' // eslint-disable-line no-unused-vars

import Stale from './stale'

const createScheduler = require('probot-scheduler')

export = (app: Application) => {

  const intervalHours = parseInt(process.env.INTERVAL_HOURS || "24")
  const staleTopic = process.env.STALE_TOPIC || "stale"

  app.log.info(`Going to be called at an inverval of ${intervalHours} hours`)

  // be careful this is called every interval for EACH repo
  createScheduler(app, {
    delay: true,
    interval: intervalHours * 60 * 60 * 1000 *  // convert hours to milliseconds
  })

  app.on('schedule.repository', async (context) => {

    const stale = new Stale(context.github, context.repo().owner, context.repo().repo);

    await stale.queryRepo()

    const query = `query {
        repository(owner: "${context.repo().owner}", name: "${context.repo().repo}") {
          id
          isFork
          updatedAt
          pushedAt
          isArchived
          isDisabled
          isLocked
          issues(first: 1, orderBy: { field: UPDATED_AT , direction: DESC} ) {
            nodes {
              updatedAt
            }
          }
          pullRequests(first: 1, orderBy: {field: UPDATED_AT, direction: DESC}) {
            nodes {
              updatedAt
            }
          }      
        }  
      }`

    const queryResult: any = await context.github.graphql(query)

    if (queryResult.isArchived || queryResult.isDisabled || queryResult.isLocked) {
      return
    }

    const updates = [
      // Don't use updated at, because adding/removing topics changes it. But this make us blind to other changes on the repo metatada
      // queryResult.repository.updatedAt,
      queryResult.repository.pushedAt
    ]

    if (queryResult.repository.issues.nodes.length > 0) {
      updates.push(queryResult.repository.issues.nodes[0].updatedAt)
    }
    if (queryResult.repository.pullRequests.nodes.length > 0) {
      updates.push(queryResult.repository.pullRequests.nodes[0].updatedAt)
    }

    context.log.debug(`${context.repo().owner}/${context.repo().repo} ${updates.toString()}`)

    const lastUpdate: Date = new Date(updates.reduce((a, b) => (Date.parse(a) > Date.parse(b) ? a : b)))

    context.log.info(`${context.repo().owner}/${context.repo().repo} lastUpdate ${lastUpdate}`)

    const lastUpdateAgo = ((new Date()).valueOf() - lastUpdate.valueOf()) / 1000

    context.log.info(`${context.repo().owner}/${context.repo().repo} ago ${lastUpdateAgo} seconds`)

    const isStale = lastUpdateAgo > 60

    const topics = await context.github.repos.listTopics({
      repo: context.repo().repo,
      owner: context.repo().owner
    })

    let names = topics.data.names

    context.log.debug(`${context.repo().owner}/${context.repo().repo} topics ${names.toString()}`)

    const hasStaleTopic = names.indexOf(staleTopic) !== -1

    context.log.info(`${context.repo().owner}/${context.repo().repo} isStale ${isStale} hasStaleTopic ${hasStaleTopic}`)

    let hasChanges = false
    if (isStale) {
      if (hasStaleTopic === false) {
        console.log('adding stale')
        hasChanges = true
        names.push(staleTopic)
      }
    } else { // not stale
      if (hasStaleTopic) {
        console.log('removing stale')
        names = names.filter(e => e !== staleTopic)
        hasChanges = true
      }
    }

    if (hasChanges) {
      console.log('updating topics' + names.toString())

      await context.github.repos.replaceTopics(
        {
          repo: context.repo().repo,
          owner: context.repo().owner,
          names: names,
          mediaType: {
            previews: [
              'mercy'
            ]
          }
        }
      )
    }
  })

  // For more information on building apps:
  // https://probot.github.io/docs/

  // To get your app running against GitHub, see:
  // https://probot.github.io/docs/development/
}
